#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# Run BATS tests inside containers for each supported base image.
# Generates Dockerfiles from templates (substituting the base image),
# builds an untagged test layer per distro+tag, then runs tests with mounts.
#
# Runs on host (macOS bash 3.2+) - no bash 4+ features.
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
SRC_DIR="${REPO_ROOT}/src"
TEMPLATES_DIR="${SRC_DIR}/test/docker-templates"
BUILD_CONTEXT="${REPO_ROOT}/target/docker"

# Image registry and prefix
REGISTRY="ghcr.io/kube-kaptain/image"
IMAGE_PREFIX="image-environment-base"

# Kubectl minor version range
KUBE_MINOR_MIN=32
KUBE_MINOR_MAX=35

# Patch levels per distro (UBI lags behind by one point release)
PATCH_alpine_3_23=4
PATCH_trixie_slim=4
PATCH_ubi_9_minimal=3
PATCH_ubuntu_24_04_lts=4

# Distros - must match Dockerfile template suffixes
DISTROS="alpine-3-23 trixie-slim ubi-9-minimal ubuntu-24-04-lts"

# Default mode: single quick validation
DEFAULT_DISTRO="trixie-slim"
DEFAULT_TAG="1.35.4"

# Counters
FAILED=0
PASSED=0
# Collected image IDs for cleanup
BUILT_IDS=""

cleanup() {
  if [[ -n "${BUILT_IDS}" ]]; then
    echo "Cleaning up test images..."
    for id in ${BUILT_IDS}; do
      docker rmi -f "${id}" 2>/dev/null || true
    done
  fi
}
trap 'cleanup' EXIT

verify_scripts_executable() {
  local scripts_dir="${SRC_DIR}/scripts"
  local failed=false

  # Directories containing executable scripts
  local dirs="
    ${scripts_dir}
    ${scripts_dir}/plugins/decryption-providers
    ${scripts_dir}/plugins/token-name-validators
    ${scripts_dir}/plugins/token-substitution-providers
    ${scripts_dir}/util
  "

  for dir in ${dirs}; do
    if [[ ! -d "${dir}" ]]; then
      continue
    fi
    for file in "${dir}"/*; do
      [[ -f "${file}" ]] || continue
      # Skip sourced libraries and docs
      case "${file}" in
        *.bash|*.md) continue ;;
      esac
      if [[ ! -x "${file}" ]]; then
        echo "  NOT EXECUTABLE: ${file#"${scripts_dir}/"}" >&2
        failed=true
      fi
    done
  done

  if [[ "${failed}" == "true" ]]; then
    echo "Pre-flight check failed: scripts above must be executable (chmod +x)" >&2
    return 1
  fi
  echo "  All scripts executable"
}

run_shellcheck() {
  echo "Running shellcheck..."
  local scripts_dir="${SRC_DIR}/scripts"
  local scripts=""

  # Directories containing scripts to check
  local dirs="
    ${scripts_dir}
    ${scripts_dir}/plugins/decryption-providers
    ${scripts_dir}/plugins/token-name-validators
    ${scripts_dir}/plugins/token-substitution-providers
    ${scripts_dir}/util
    ${scripts_dir}/defaults
  "

  for dir in ${dirs}; do
    if [[ ! -d "${dir}" ]]; then
      continue
    fi
    for file in "${dir}"/*; do
      [[ -f "${file}" ]] || continue
      # Skip docs
      case "${file}" in
        *.md) continue ;;
      esac
      scripts="${scripts} ${file}"
    done
  done

  if [[ -z "${scripts}" ]]; then
    echo "  No scripts found to check"
    return 0
  fi

  # Style checks to enable (same as buildon-github-actions)
  local enables="
    --external-sources
    --enable=require-variable-braces
    --enable=require-double-brackets
    --enable=avoid-nullary-conditions
    --enable=check-unassigned-uppercase
    --enable=deprecate-which
  "

  local script_count
  script_count=$(echo ${scripts} | wc -w | tr -d ' ')
  echo "  Checking ${script_count} scripts"

  # shellcheck disable=SC2086
  if command -v shellcheck >/dev/null 2>&1; then
    shellcheck ${enables} ${scripts}
  else
    docker run --rm \
      -v "${REPO_ROOT}:/workspace" \
      koalaman/shellcheck:v0.10.0 \
      ${enables} $(echo ${scripts} | sed "s|${REPO_ROOT}|/workspace|g")
  fi

  echo "  shellcheck passed"
}

prepare_build_context() {
  rm -rf "${BUILD_CONTEXT}"
  mkdir -p "${BUILD_CONTEXT}"
  cp "${TEMPLATES_DIR}/run-bats.bash" "${BUILD_CONTEXT}/"
}

generate_dockerfile() {
  local distro="$1"
  local base_image="$2"
  local template="${TEMPLATES_DIR}/Dockerfile.${distro}"
  local output="${BUILD_CONTEXT}/Dockerfile.${distro}"

  sed "s|{{BASE_IMAGE}}|${base_image}|g" "${template}" > "${output}"
}

build_test_image() {
  local distro="$1"
  local tag="$2"
  local base_image="${REGISTRY}/${IMAGE_PREFIX}-${distro}:${tag}"

  generate_dockerfile "${distro}" "${base_image}"

  echo "  Building ${distro}:${tag}..." >&2
  local image_id
  image_id=$(docker build -q --no-cache \
    -f "${BUILD_CONTEXT}/Dockerfile.${distro}" \
    "${BUILD_CONTEXT}")

  BUILT_IDS="${BUILT_IDS} ${image_id}"
  echo "${image_id}"
}

run_tests_in_container() {
  local image_id="$1"
  local label="$2"
  local bats_args=""
  if [[ -n "${ONE_BATS:-}" ]]; then
    bats_args="/run/test/${ONE_BATS}.bats"
    label="${label} [${ONE_BATS}]"
  fi

  echo "Running tests: ${label}"

  if docker run --rm \
    -v "${SRC_DIR}/scripts:/run/bin:ro" \
    -v "${SRC_DIR}/test:/run/test:ro" \
    -v "${SRC_DIR}/test/fixtures/manifests:/run/fixtures/manifests:ro" \
    -v "${SRC_DIR}/test/fixtures/secrets:/run/fixtures/secrets:ro" \
    -v "${SRC_DIR}/test/fixtures/templates:/run/fixtures/templates:ro" \
    -e "PATH=/run/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" \
    "${image_id}" \
    run-bats ${bats_args}; then
    echo "  PASSED: ${label}"
    PASSED=$((PASSED + 1))
  else
    echo "  FAILED: ${label}"
    FAILED=$((FAILED + 1))
  fi
  echo ""
}

patch_for_distro() {
  local distro="$1"
  # Bash 3.2 compatible: no associative arrays
  local key
  key="PATCH_$(echo "${distro}" | tr '-' '_')"
  eval "echo \${${key}}"
}

run_matrix() {
  for distro in ${DISTROS}; do
    echo "--- Distro: ${distro} ---"
    local patch
    patch=$(patch_for_distro "${distro}")
    local minor=${KUBE_MINOR_MIN}
    while [[ ${minor} -le ${KUBE_MINOR_MAX} ]]; do
      local tag="1.${minor}.${patch}"
      local base_image="${REGISTRY}/${IMAGE_PREFIX}-${distro}:${tag}"
      local image_id
      image_id=$(build_test_image "${distro}" "${tag}")
      run_tests_in_container "${image_id}" "${distro}:${tag}"
      run_host_side_tests "${base_image}" "${distro}:${tag}"
      minor=$((minor + 1))
    done
  done
}

run_default() {
  echo "--- Default: ${DEFAULT_DISTRO}:${DEFAULT_TAG} ---"
  local base_image="${REGISTRY}/${IMAGE_PREFIX}-${DEFAULT_DISTRO}:${DEFAULT_TAG}"
  local image_id
  image_id=$(build_test_image "${DEFAULT_DISTRO}" "${DEFAULT_TAG}")
  run_tests_in_container "${image_id}" "${DEFAULT_DISTRO}:${DEFAULT_TAG}"
  run_host_side_tests "${base_image}" "${DEFAULT_DISTRO}:${DEFAULT_TAG}"
}

run_host_side_tests() {
  local base_image="$1"
  local label="$2"

  # Skip if running specific bats file that isn't the host-side tests
  if [[ -n "${ONE_BATS:-}" && "${ONE_BATS}" != "entrypoint-scripts" ]]; then
    return 0
  fi

  echo "Running host-side tests: ${label}"

  if TEST_IMAGE="${base_image}" \
     SCRIPTS_DIR="${SRC_DIR}/scripts" \
     bats "${SRC_DIR}/test/host-side/entrypoint-scripts.bats"; then
    echo "  PASSED: host-side ${label}"
    PASSED=$((PASSED + 1))
  else
    echo "  FAILED: host-side ${label}"
    FAILED=$((FAILED + 1))
  fi
  echo ""
}

main() {
  # Install BATS if not available (CI environments like GitHub Actions ubuntu-24.04)
  if ! command -v bats &>/dev/null; then
    echo "Installing BATS..."
    sudo apt-get update -qq && sudo apt-get install -y -qq bats
  fi

  local run_all=false
  ONE_BATS=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all) run_all=true ;;
      --one)
        shift
        ONE_BATS="$1"
        ;;
      --help|-h)
        echo "Usage: run-tests [--all] [--one <name>]"
        echo "  Default: runs ${DEFAULT_DISTRO}:${DEFAULT_TAG} only"
        echo "  --all:   runs full matrix (all distros Ã— kubectl 1.${KUBE_MINOR_MIN}-1.${KUBE_MINOR_MAX})"
        echo "  --one:   run only the named .bats file (without .bats extension)"
        exit 0
        ;;
    esac
    shift
  done

  echo "=== Kaptain Deploy Scripts Test Runner ==="
  if [[ -n "${ONE_BATS}" ]]; then
    echo "Bats file: ${ONE_BATS}.bats"
  fi
  if [[ "${run_all}" == "true" ]]; then
    echo "Mode: full matrix"
    echo "kubectl versions: 1.${KUBE_MINOR_MIN} - 1.${KUBE_MINOR_MAX}"
  else
    echo "Mode: default (${DEFAULT_DISTRO}:${DEFAULT_TAG})"
  fi
  echo ""

  echo "Pre-flight checks..."
  verify_scripts_executable

  run_shellcheck

  prepare_build_context

  if [[ "${run_all}" == "true" ]]; then
    run_matrix
  else
    run_default
  fi

  echo "=== Results ==="
  echo "Passed: ${PASSED}"
  echo "Failed: ${FAILED}"
  if [[ ${FAILED} -gt 0 ]]; then
    exit 1
  fi
}

main "$@"
