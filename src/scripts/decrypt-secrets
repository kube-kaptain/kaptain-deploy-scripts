#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# Decrypt all secret files from secrets dir to decrypted dir.
# Handles nested paths: /run/secrets/foo/bar.age â†’ decrypted/foo/bar
# Token substitution uses relative path: ${foo/bar} (shell style)
#
# Expects all files to use the same encryption suffix (.age recommended).
# Tolerates individual decryption failures (wrong key, operator error)
# but reports them clearly at the end.
set -euo pipefail

base="${RUN_BASE_PATH:-/run}"
secrets_dir="${base}/secrets"
decrypted_dir="${base}/work/decrypted"

# Known suffixes, longest first to avoid partial matches
SUFFIXES=(
  ".sha256.aes256.100k"
  ".sha256.aes256.600k"
  ".sha256.aes256.10k"
  ".sha256.aes256"
  ".age"
)

if [[ ! -d "${secrets_dir}" ]]; then
  notify-error "Secrets directory missing: ${secrets_dir}"
  notify-error "This is built into the base image - should not happen"
  exit 46
fi

if [[ ! -d "${decrypted_dir}" ]]; then
  notify-error "Decrypted directory missing: ${decrypted_dir}"
  notify-error "This is created by 'deploy' - should not happen"
  exit 46
fi

log "Decrypting secrets from ${secrets_dir} to ${decrypted_dir}"

# Find all files recursively, get relative paths
secret_files=()
while IFS= read -r file; do
  file="${file#./}"
  secret_files+=("${file}")
done < <(cd "${secrets_dir}" && find . -type f)

# Empty directory is fine
if [[ ${#secret_files[@]} -eq 0 ]]; then
  notify-info "No secret files to decrypt"
  exit 0
fi

# Check all files have the same suffix
declare -A suffix_counts
for file in "${secret_files[@]}"; do
  matched=""
  for suffix in "${SUFFIXES[@]}"; do
    if [[ "${file}" == *"${suffix}" ]]; then
      matched="${suffix}"
      break
    fi
  done
  if [[ -z "${matched}" ]]; then
    matched="UNKNOWN"
  fi
  suffix_counts["${matched}"]=$(( ${suffix_counts["${matched}"]:-0} + 1 ))
done

# Report and fail if mixed suffixes
if [[ ${#suffix_counts[@]} -gt 1 ]]; then
  message="Mixed encryption suffixes found - all secrets must use the same format"
  for suffix in "${!suffix_counts[@]}"; do
    message+=$'\n'"  ${suffix}: ${suffix_counts[${suffix}]} files"
  done
  message+=$'\n'"Recommendation: use .age for all secrets"
  notify-error "${message}"
  exit 47
fi

# Get the single suffix in use
encryption_suffix="${!suffix_counts[*]}"
if [[ "${encryption_suffix}" == "UNKNOWN" ]]; then
  message="No recognised encryption suffix found"
  message+=$'\n'"Known suffixes: ${SUFFIXES[*]}"
  message+=$'\n'"Recommendation: use .age"
  notify-error "${message}"
  exit 47
fi

# Process all files, tolerating failures
succeeded=0
failed=0
failed_files=()

for file in "${secret_files[@]}"; do
  if decrypt-secret "${file}" "${encryption_suffix}"; then
    succeeded=$((succeeded + 1))
  else
    failed=$((failed + 1))
    failed_files+=("${file}")
  fi
done

# Report results
if [[ ${failed} -gt 0 ]]; then
  message="${failed} files failed to decrypt - key wrong or encrypted wrongly"
  for file in "${failed_files[@]}"; do
    message+=$'\n'"  - ${file}"
  done
  notify-error "${message}"
  exit 49
fi

notify-info "Decrypted ${succeeded} secrets using ${encryption_suffix#.}"
