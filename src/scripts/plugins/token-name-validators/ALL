#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# ALL - Validates token names with minimal restrictions
#
# All naming styles accepted, but must:
# - Start and end with alphanumeric characters
# - Only contain: a-zA-Z0-9._-
#
# This blocks hidden files (.gitkeep, .DS_Store) and malformed names (-leading, trailing-)
#
# Valid: my-var-2, my_2_var, MY.2.VAR, 2MyVar, var2, a, my-category/my_sub_var
# Invalid: .gitkeep, -leading, trailing-, my;var
#
# Usage:
#   ALL <directory>
#
set -euo pipefail

LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

if [[ ${#} -ne 1 ]]; then
  echo "${LOG_ERROR_PREFIX}Usage: ALL <directory>${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

DIR="${1}"

if [[ ! -d "${DIR}" ]]; then
  echo "${LOG_ERROR_PREFIX}Directory not found: ${DIR}${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

is_valid_name() {
  local name="${1}"

  local segment
  while IFS= read -r segment; do
    # Regex: ^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?$
    # Single char: must be alphanumeric
    # Multi char: start/end alphanumeric, middle can have dots, underscores, hyphens
    if [[ ${#segment} -eq 1 ]]; then
      if [[ ! "${segment}" =~ ^[a-zA-Z0-9]$ ]]; then
        return 1
      fi
    else
      if [[ ! "${segment}" =~ ^[a-zA-Z0-9][a-zA-Z0-9._-]*[a-zA-Z0-9]$ ]]; then
        return 1
      fi
    fi
  done <<< "${name//\//$'\n'}"

  return 0
}

invalid_names=()

while IFS= read -r -d '' file; do
  rel_path="${file#"${DIR}"/}"

  if ! is_valid_name "${rel_path}"; then
    invalid_names+=("${rel_path}")
  fi
done < <(find "${DIR}" -type f -print0)

if [[ ${#invalid_names[@]} -gt 0 ]]; then
  echo "${LOG_ERROR_PREFIX}Invalid token names:${LOG_ERROR_SUFFIX}" >&2
  for name in "${invalid_names[@]}"; do
    echo "  ${name}" >&2
  done
  exit 1
fi

exit 0
