#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# substitute-tokens-from-dir - Generic token substitution orchestrator
#
# Processes all token files in a directory and substitutes them into target files.
# Token files: filename = token name, file content = token value.
# Supports nested directories: path becomes part of token name (e.g., category/my-var).
#
# Usage:
#   substitute-tokens-from-dir <token-style> <tokens-dir> <target-file-or-dir>
#
# Arguments:
#   token-style        - Substitution syntax (shell, mustache, helm, erb, github-actions, etc.)
#   tokens-dir         - Directory containing token files
#   target-file-or-dir - File or directory to substitute into (modified in-place)
#
# Environment:
#   CONFIG_VALUE_TRAILING_NEWLINE - How to handle trailing newlines in token values
#                                   (strip-for-single-line, preserve-all, always-strip-one-newline)
#
# Example:
#   substitute-tokens-from-dir shell target/manifests/config target/manifests/substituted
#
set -euo pipefail

# Locate script directory for finding plugins
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLUGINS_DIR="${SCRIPT_DIR}/../plugins"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# shellcheck source=src/scripts/defaults/tokens.bash
source "${SCRIPT_DIR}/../defaults/tokens.bash"
export CONFIG_VALUE_TRAILING_NEWLINE

# Validate arguments
if [[ $# -ne 3 ]]; then
  echo "${LOG_ERROR_PREFIX}Usage: substitute-tokens-from-dir <token-style> <tokens-dir> <target-file-or-dir>${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

TOKEN_STYLE="${1:-shell}"
TOKENS_DIR="${2}"
TARGET="${3}"

# Validate token style script exists
PROVIDER_SCRIPT="${PLUGINS_DIR}/token-substitution-providers/substitute-${TOKEN_STYLE}-style-token"
if [[ ! -x "${PROVIDER_SCRIPT}" ]]; then
  echo "${LOG_ERROR_PREFIX}Unknown token style: ${TOKEN_STYLE} (script not found: substitute-${TOKEN_STYLE}-style-token)${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Validate tokens directory exists
if [[ ! -d "${TOKENS_DIR}" ]]; then
  echo "${LOG_ERROR_PREFIX}Tokens directory not found: ${TOKENS_DIR}${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Validate target exists (file or directory)
if [[ -d "${TARGET}" ]]; then
  TARGET_MODE="dir"
elif [[ -f "${TARGET}" ]]; then
  TARGET_MODE="file"
else
  echo "${LOG_ERROR_PREFIX}Target not found: ${TARGET}${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Check for symlinks in tokens directory (security: prevent path traversal)
symlinks_found=()
while IFS= read -r -d '' symlink; do
  symlinks_found+=("${symlink}")
done < <(find "${TOKENS_DIR}" -type l -print0)

if [[ ${#symlinks_found[@]} -gt 0 ]]; then
  echo "${LOG_ERROR_PREFIX}Symlinks not allowed in tokens directory:${LOG_ERROR_SUFFIX}" >&2
  for symlink in "${symlinks_found[@]}"; do
    echo "  ${symlink#"${TOKENS_DIR}"/}" >&2
  done
  exit 1
fi

# Check for binary files (null bytes) in tokens directory
# Use portable detection: compare file with null-bytes-stripped version
binary_files_found=()
while IFS= read -r -d '' token_file; do
  # shellcheck disable=SC2094 # False positive: we read the file to check, not write to it
  if ! LC_ALL=C tr -d '\0' < "${token_file}" | cmp -s - "${token_file}"; then
    binary_files_found+=("${token_file}")
  fi
done < <(find "${TOKENS_DIR}" -type f -print0)

if [[ ${#binary_files_found[@]} -gt 0 ]]; then
  echo "${LOG_ERROR_PREFIX}Binary files (containing null bytes) not allowed in tokens directory:${LOG_ERROR_SUFFIX}" >&2
  for binary_file in "${binary_files_found[@]}"; do
    echo "  ${binary_file#"${TOKENS_DIR}"/}" >&2
  done
  exit 1
fi

# Build list of target files (absolute paths)
# Router handles file iteration - providers only receive single files
TARGET_FILES=()
if [[ "${TARGET_MODE}" == "dir" ]]; then
  TARGET_ABS="$(cd "${TARGET}" && pwd)"
  while IFS= read -r -d '' file; do
    TARGET_FILES+=("${file}")
  done < <(find "${TARGET_ABS}" -type f -print0)
else
  # For files, get absolute path
  TARGET_ABS="$(cd "$(dirname "${TARGET}")" && pwd)/$(basename "${TARGET}")"
  TARGET_FILES=("${TARGET_ABS}")
fi

# Process tokens from tokens directory
# cd to tokens-dir so token paths are relative (become token names)
cd "${TOKENS_DIR}"

# Build list of token files (sorted for predictable order)
# LC_ALL=C ensures consistent sorting across locales
TOKEN_FILES=()
while IFS= read -r token_file; do
  # Strip ./ prefix from find output
  TOKEN_FILES+=("${token_file#./}")
done < <(find . -type f | LC_ALL=C sort)

# Output header first (real-time output for debugging)
echo "Substituting tokens in ${TARGET}:"

# Process each target file, outputting count as we go
# Outer loop: files, Inner loop: tokens - enables real-time per-file output
for target_file in "${TARGET_FILES[@]}"; do
  file_count=0

  # Apply all tokens to this file (skip if no tokens)
  if [[ ${#TOKEN_FILES[@]} -gt 0 ]]; then
    for token_file in "${TOKEN_FILES[@]}"; do
      count=$("${PROVIDER_SCRIPT}" "${token_file}" "${target_file}")
      file_count=$((file_count + count))
    done
  fi

  # Output immediately after processing each file
  if [[ "${TARGET_MODE}" == "dir" ]]; then
    relative_path="${target_file#"${TARGET_ABS}"/}"
  else
    relative_path="$(basename "${target_file}")"
  fi
  if [[ ${file_count} -eq 0 ]]; then
    echo "  Substituted no tokens in ${relative_path}"
  else
    echo "  Substituted ${file_count} tokens in ${relative_path}"
  fi
done
